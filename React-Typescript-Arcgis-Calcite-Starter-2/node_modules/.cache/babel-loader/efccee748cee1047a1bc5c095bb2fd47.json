{"ast":null,"code":"import { camelToDashCase } from './case';\nexport const attachProps = (node, newProps, oldProps = {}) => {\n  // some test frameworks don't render DOM elements, so we test here to make sure we are dealing with DOM first\n  if (node instanceof Element) {\n    // add any classes in className to the class list\n    const className = getClassName(node.classList, newProps, oldProps);\n\n    if (className !== '') {\n      node.className = className;\n    }\n\n    Object.keys(newProps).forEach(name => {\n      if (name === 'children' || name === 'style' || name === 'ref' || name === 'class' || name === 'className' || name === 'forwardedRef') {\n        return;\n      }\n\n      if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {\n        const eventName = name.substring(2);\n        const eventNameLc = eventName[0].toLowerCase() + eventName.substring(1);\n\n        if (typeof document !== 'undefined' && !isCoveredByReact(eventNameLc, document)) {\n          syncEvent(node, eventNameLc, newProps[name]);\n        }\n      } else {\n        node[name] = newProps[name];\n        const propType = typeof newProps[name];\n\n        if (propType === 'string') {\n          node.setAttribute(camelToDashCase(name), newProps[name]);\n        } else {\n          node[name] = newProps[name];\n        }\n      }\n    });\n  }\n};\nexport const getClassName = (classList, newProps, oldProps) => {\n  const newClassProp = newProps.className || newProps.class;\n  const oldClassProp = oldProps.className || oldProps.class; // map the classes to Maps for performance\n\n  const currentClasses = arrayToMap(classList);\n  const incomingPropClasses = arrayToMap(newClassProp ? newClassProp.split(' ') : []);\n  const oldPropClasses = arrayToMap(oldClassProp ? oldClassProp.split(' ') : []);\n  const finalClassNames = []; // loop through each of the current classes on the component\n  // to see if it should be a part of the classNames added\n\n  currentClasses.forEach(currentClass => {\n    if (incomingPropClasses.has(currentClass)) {\n      // add it as its already included in classnames coming in from newProps\n      finalClassNames.push(currentClass);\n      incomingPropClasses.delete(currentClass);\n    } else if (!oldPropClasses.has(currentClass)) {\n      // add it as it has NOT been removed by user\n      finalClassNames.push(currentClass);\n    }\n  });\n  incomingPropClasses.forEach(s => finalClassNames.push(s));\n  return finalClassNames.join(' ');\n};\n/**\n * Checks if an event is supported in the current execution environment.\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */\n\nexport const isCoveredByReact = (eventNameSuffix, doc) => {\n  const eventName = 'on' + eventNameSuffix;\n  let isSupported = (eventName in doc);\n\n  if (!isSupported) {\n    const element = doc.createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof element[eventName] === 'function';\n  }\n\n  return isSupported;\n};\nexport const syncEvent = (node, eventName, newEventHandler) => {\n  const eventStore = node.__events || (node.__events = {});\n  const oldEventHandler = eventStore[eventName]; // Remove old listener so they don't double up.\n\n  if (oldEventHandler) {\n    node.removeEventListener(eventName, oldEventHandler);\n  } // Bind new listener.\n\n\n  node.addEventListener(eventName, eventStore[eventName] = function handler(e) {\n    if (newEventHandler) {\n      newEventHandler.call(this, e);\n    }\n  });\n};\n\nconst arrayToMap = arr => {\n  const map = new Map();\n  arr.forEach(s => map.set(s, s));\n  return map;\n};","map":{"version":3,"sources":["../../../src/react-component-lib/utils/attachProps.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { camelToDashCase } from './case';\nexport const attachProps = (node, newProps, oldProps = {}) => {\n    // some test frameworks don't render DOM elements, so we test here to make sure we are dealing with DOM first\n    if (node instanceof Element) {\n        // add any classes in className to the class list\n        const className = getClassName(node.classList, newProps, oldProps);\n        if (className !== '') {\n            node.className = className;\n        }\n        Object.keys(newProps).forEach((name) => {\n            if (name === 'children' ||\n                name === 'style' ||\n                name === 'ref' ||\n                name === 'class' ||\n                name === 'className' ||\n                name === 'forwardedRef') {\n                return;\n            }\n            if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {\n                const eventName = name.substring(2);\n                const eventNameLc = eventName[0].toLowerCase() + eventName.substring(1);\n                if (typeof document !== 'undefined' && !isCoveredByReact(eventNameLc, document)) {\n                    syncEvent(node, eventNameLc, newProps[name]);\n                }\n            }\n            else {\n                node[name] = newProps[name];\n                const propType = typeof newProps[name];\n                if (propType === 'string') {\n                    node.setAttribute(camelToDashCase(name), newProps[name]);\n                }\n                else {\n                    node[name] = newProps[name];\n                }\n            }\n        });\n    }\n};\nexport const getClassName = (classList, newProps, oldProps) => {\n    const newClassProp = newProps.className || newProps.class;\n    const oldClassProp = oldProps.className || oldProps.class;\n    // map the classes to Maps for performance\n    const currentClasses = arrayToMap(classList);\n    const incomingPropClasses = arrayToMap(newClassProp ? newClassProp.split(' ') : []);\n    const oldPropClasses = arrayToMap(oldClassProp ? oldClassProp.split(' ') : []);\n    const finalClassNames = [];\n    // loop through each of the current classes on the component\n    // to see if it should be a part of the classNames added\n    currentClasses.forEach((currentClass) => {\n        if (incomingPropClasses.has(currentClass)) {\n            // add it as its already included in classnames coming in from newProps\n            finalClassNames.push(currentClass);\n            incomingPropClasses.delete(currentClass);\n        }\n        else if (!oldPropClasses.has(currentClass)) {\n            // add it as it has NOT been removed by user\n            finalClassNames.push(currentClass);\n        }\n    });\n    incomingPropClasses.forEach((s) => finalClassNames.push(s));\n    return finalClassNames.join(' ');\n};\n/**\n * Checks if an event is supported in the current execution environment.\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */\nexport const isCoveredByReact = (eventNameSuffix, doc) => {\n    const eventName = 'on' + eventNameSuffix;\n    let isSupported = eventName in doc;\n    if (!isSupported) {\n        const element = doc.createElement('div');\n        element.setAttribute(eventName, 'return;');\n        isSupported = typeof element[eventName] === 'function';\n    }\n    return isSupported;\n};\nexport const syncEvent = (node, eventName, newEventHandler) => {\n    const eventStore = node.__events || (node.__events = {});\n    const oldEventHandler = eventStore[eventName];\n    // Remove old listener so they don't double up.\n    if (oldEventHandler) {\n        node.removeEventListener(eventName, oldEventHandler);\n    }\n    // Bind new listener.\n    node.addEventListener(eventName, (eventStore[eventName] = function handler(e) {\n        if (newEventHandler) {\n            newEventHandler.call(this, e);\n        }\n    }));\n};\nconst arrayToMap = (arr) => {\n    const map = new Map();\n    arr.forEach((s) => map.set(s, s));\n    return map;\n};\n//# sourceMappingURL=attachProps.js.map"]},"metadata":{},"sourceType":"module"}